#include "chunk.hpp"

chunk_t::chunk_t()
	:content(width,
			std::vector<std::vector<block_type>>(height,
				std::vector<block_type>(depth, block_type::none)))
	,is_autogenerated(width,
			std::vector<std::vector<bool>>(height,
				std::vector<bool>(depth, true)))
{ }

// void chunk_t::update_buffers() {
// 	vertex_buffer.clear();
// 	// vertex_colors.clear();
// 	vertex_uvs.clear();
//
// 	for (size_t x = 0; x < content.size(); ++x) {
// 		for (size_t y = 0; y < content[x].size(); ++y) {
// 			for (size_t z = 0; z < content[x][y].size(); ++z) {
// 				if (content[x][y][z] == block_type::none) continue;
//
// 				for (size_t i = 0; i < single_block_points_cnt; ++i) {
// 					const glm::vec3 pos(
// 						single_block_positions[3*i+0] + 2.0f * x,
// 						single_block_positions[3*i+1] + 2.0f * y,
// 						single_block_positions[3*i+2] + -2.0f * z
// 					);
// 					vertex_buffer.push_back(pos.x / 2.0f);
// 					vertex_buffer.push_back(pos.y / 2.0f);
// 					vertex_buffer.push_back(pos.z / 2.0f);
//
// 					const glm::vec2 uv(
// 						single_block_uv[2*i+0],
// 						single_block_uv[2*i+1]
// 					);
// 					vertex_uvs.push_back(uv.x);
// 					vertex_uvs.push_back(uv.y);
//
// 					const glm::vec3 normal(
// 						single_block_normals[3*i+0] + 2.0f * x,
// 						single_block_normals[3*i+1] + 2.0f * y,
// 						single_block_normals[3*i+2] + -2.0f * z
// 					);
// 					vertex_normals.push_back(normal.x / 2.0f);
// 					vertex_normals.push_back(normal.y / 2.0f);
// 					vertex_normals.push_back(normal.z / 2.0f);
// 				}
// 			}
// 		}
// 	}
// }
